#  Списки (Lists): Задачи для самостоятельной работы

#  Задача 1: Клубный фейсконтроль

#  Сценарий: Отфильтровать список возрастов, оставив только тех, кто достиг 18 лет.
#  •	На входе: Список чисел. [25, 17, 18, 31, 16, 22]
#  •	На выходе: Список чисел, прошедших фильтр. [25, 18, 31, 22]
#  Подсказка: Понадобится пустой список для результатов и цикл с условным добавлением.

list_age = [23, 17, 18, 31, 16, 22, 15, 33]
numbers = []
# n = len(list_age)
for age in list_age:
   if age >= 18:
      numbers.append(age)
print(numbers)


# Задача 2: Магическое превращение

# Сценарий: Заменить в списке одни элементы на другие по заданным правилам ("лягушка" -> "принц", "тыква" -> "карета"), не трогая остальные.
# •	На входе: Список строк. ['камень', 'лягушка', 'вода', 'тыква', 'лягушка']
# •	На выходе: Новый список с результатами замен. ['камень', 'принц', 'вода', 'карета', 'принц']
# Подсказка: Для обработки нескольких разных условий идеально подходит конструкция if/elif/else.

list_1 = ['камень', 'лягушка', 'вода', 'тыква', 'лягушка']
replace_dict = {'лягушка': "принц", 'тыква': "карета"}
for s in range(len(list_1)):
   if list_1[s] in replace_dict:
      list_1[s] = replace_dict[list_1[s]]
print(list_1)


# Задача 3: Перепись в зоопарке

# Сценарий: Посчитать количество элементов двух разных категорий (хищники и травоядные) в одном общем списке.
# •	На входе: Список строк (животных). ['лев', 'зебра', 'тигр', 'жираф', 'волк', 'слон']
# •	На выходе: Два числа — количество элементов каждой категории. "Хищников: 3, Травоядных: 3"
# Подсказка: Чтобы отличить одну категорию от другой, удобно хранить одну из них в отдельной небольшой коллекции для быстрой проверки с помощью оператора in.

animals =  ['лев', 'зебра', 'тигр', 'жираф', 'волк', 'слон']
vegan = ['зебра', 'жираф', 'слон']
predator = ['лев', 'тигр', 'волк']
count_vegan = sum(1 for animal in animals if animal in vegan)
count_predator = sum(1 for animal in animals if animal in predator)
print(f'травоядных: ', count_vegan, '\n''хищников: ', count_predator)


# Задача 4: Горный поход

# Сценарий: У вас есть список высот, которые альпинист фиксировал каждый час. Вам нужно найти самый длинный непрерывный участок, где он только поднимался (каждая следующая высота больше предыдущей).
# •	На входе: Список чисел. [100, 110, 105, 120, 125, 130, 128]
# •	На выходе: Список, представляющий самый длинный подъем. [120, 125, 130]
# Подсказка: Вам понадобятся переменные для отслеживания как текущей, так и самой длинной найденной последовательности

# high =  [100, 110, 105, 120, 125, 130, 128]
# top = []
# for h in range(len(high)):
#    if h == 100:
#       top.append(h)
#    # else:
#    #    continue
#    print(top)


# Задача 5: Диагонали магического квадрата

# Сценарий: У вас есть матрица (список списков), представляющая магический квадрат. Вам нужно посчитать сумму элементов на главной и побочной диагоналях.
# •	На входе: Список списков одинаковой длины. [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
# •	На выходе: Два числа. "Сумма главной диагонали: 15. Сумма побочной диагонали: 15."
# Подсказка: Ключ к решению — найти математическую связь между индексами строки и столбца для каждой из диагоналей.

# matrix = [[1, 2, 3], 
#           [4, 5, 6], 
#           [7, 8, 9]]



# Кортежи (Tuples): Задачи для самостоятельной работы

# Задача 1: Бюджетные покупки

# Сценарий: Из списка кортежей (название, цена) выбрать только названия тех товаров, цена которых удовлетворяет условию.
# •	На входе: Список кортежей. [('книга', 800), ('ручка', 50), ('рюкзак', 1500)]
# •	На выходе: Список строк (названий). ['книга', 'ручка']
# Подсказка: В цикле обращайтесь к элементам кортежа по их индексам для проверки условия и извлечения нужных данных.


items = [('книга', 800), ('ручка', 50), ('рюкзак', 1500)]

items_cheap = []

for item in items:
   name = item[0]
   price = item[1]
   if price < 1000:
      items_cheap.append(name)

print(items_cheap)


# Задача 2: Лучший результат экзамена

# Сценарий: Найти в списке кортежей (имя, балл) имя, соответствующее максимальному баллу.
# •	На входе: Список кортежей. [('Анна', 92), ('Борис', 88), ('Виктор', 95)]
# •	На выходе: Строка (имя). "Виктор"
# Подсказка: Вам понадобятся переменные для хранения как максимального найденного значения, так и соответствующего ему имени.


exams = [('Анна', 92), ('Борис', 88), ('Виктор', 95)]
max_ball = 0
best = ''

for name, ball in exams:
   if ball > max_ball:
      max_ball = ball
      best = name

print(best)


# Задача 3: Распределение по отделам

# Сценарий: Распределить элементы из одного списка кортежей (имя, отдел) по двум разным спискам в зависимости от значения "отдел".
# •	На входе: Список кортежей. [('Иван', 'IT'), ('Мария', 'HR'), ('Петр', 'IT')]
# •	На выходе: Два списка с именами. it_team = ['Иван', 'Петр'], hr_team = ['Мария']
# Подсказка: Заранее создайте пустые списки для каждой категории и наполняйте их в цикле, анализируя второй элемент каждого кортежа.


work_list = [('Иван', 'IT'), ('Мария', 'HR'), ('Петр', 'IT')]
it_team = []
hr_team = []

for name, team in work_list:
   if team == 'IT':
      it_team.append(name)
   else:
      hr_team.append(name)
   
print('it-team = ', it_team,'\n', 'hr-team = ', hr_team)


# Задача 4: Сортировка гоночного протокола

# Сценарий: У вас есть список результатов гонки в виде кортежей (имя_гонщика, время_круга). Вам нужно отсортировать этот список по времени круга, от лучшего (меньшего) к худшему.
# •	На входе: Список кортежей. [('Льюис', 91.5), ('Макс', 91.2), ('Шарль', 92.1)]
# •	На выходе: Новый, отсортированный список кортежей. [('Макс', 91.2), ('Льюис', 91.5), ('Шарль', 92.1)]
# Подсказка: Встроенные функции сортировки в Python позволяют указать «ключ» — функцию, которая будет применяться к каждому элементу перед сравнением.


speeds = [('Льюис', 91.5), ('Макс', 91.2), ('Шарль', 92.1)]
# speeds_sort = []

speeds_sort = sorted(speeds, key=lambda x: x[1])
print(speeds_sort)


# Задача 5: Студент с лучшей средней оценкой

# Сценарий: Дан список студентов, где каждый представлен кортежем (имя, список_оценок). Вам нужно найти имя студента с самой высокой средней оценкой.
# •	На входе: Список кортежей. [('Анна', [5, 5, 4]), ('Борис', [4, 3, 5]), ('Виктор', [5, 5, 5])]
# •	На выходе: Строка с именем лучшего студента. "Виктор"
# Подсказка: Внутри основного цикла вам понадобится вложенная логика для вычисления среднего значения для каждого студента перед тем, как сравнивать его с лучшим результатом.


# Множества (Sets): Задачи для самостоятельной работы

# Задача 1: Общие друзья

# Сценарий: Найти общие элементы в двух списках.
# •	На входе: Два списка. my_friends = ['Аня', 'Петя', 'Вася'], his_friends = ['Коля', 'Петя', 'Аня']
# •	На выходе: Список или множество общих элементов. {'Аня', 'Петя'}
# Подсказка: Преобразование списков в множества сильно упростит задачу и сделает код эффективнее.


my_friends = ['Аня', 'Петя', 'Вася']
his_friends = ['Коля', 'Петя', 'Аня']

my_friends = set(my_friends)
his_friends = set(his_friends)

friends_union = my_friends.intersection(his_friends)

print(friends_union)


# Задача 2: Уникальные гости

# Сценарий: Удалить дубликаты из списка, сохранив порядок первого появления элементов.
# •	На входе: Список с дубликатами. ['Иван', 'Анна', 'Петр', 'Анна', 'Иван']
# •	На выходе: Список без дубликатов. ['Иван', 'Анна', 'Петр']
# Подсказка: Простое преобразование в set и обратно потеряет порядок. Чтобы его сохранить, нужно использовать одновременно и список (для результата), и множество (для быстрой проверки).


dubles = ['Иван', 'Петр', 'Анна', 'Петр', 'Анна', 'Иван']
results = []

for name in dubles:
   if name not in results:
      results.append(name)

print(results)


# Задача 3: Незавершенные дела

# Сценарий: Найти элементы, которые есть в одном списке, но отсутствуют в другом.
# •	На входе: Два списка. all_tasks = ['помыть посуду', 'погулять'], completed_tasks = ['помыть посуду']
# •	На выходе: Список с "разницей". ['погулять']
# Подсказка: Эта задача — классический пример на нахождение разности. Множества делают это очень изящно.


all_tasks = ['помыть посуду', 'погулять']
completed_tasks = ['помыть посуду']

tasks_union = set(all_tasks).difference(set(completed_tasks))

print(tasks_union)


# Задача 4: Уникальные книги

# Сценарий: У вас и у друга есть полки с книгами. Нужно найти все книги, которые есть только у вас и только у вашего друга, но не те, что есть у вас обоих.
# •	На входе: Два списка или множества. my_books = {'Война и мир', '1984'}, friend_books = {'1984', 'Мастер и Маргарита'}.
# •	На выходе: Множество уникальных для каждого книг. {'Война и мир', 'Мастер и Маргарита'}
# Подсказка: Эту задачу можно решить, найдя все книги (объединение) и удалив из них те, что есть у обоих (пересечение). Или можно найти специальный метод для множеств, который делает это в один шаг.


my_books = {'Война и мир', '1984'}
friend_books = {'1984', 'Мастер и Маргарита'}

different_books = my_books ^ friend_books

print(different_books)


# Задача 5: Язык переговоров

# Сценарий: На встречу приехали несколько послов, каждый из которых говорит на определённом наборе языков. Вам нужно найти все языки, на которых могут говорить все послы, чтобы выбрать язык для переговоров.
# •	На входе: Список, где каждый элемент — это множество языков одного посла. [ {'английский', 'испанский'}, {'английский', 'французский'}, {'английский', 'немецкий'} ]
# •	На выходе: Множество языков, общих для всех. {'английский'}
# Подсказка: Начните с множества языков первого человека и в цикле последовательно находите пересечение этого результата с множествами остальных.


# languagies = [ {'английский', 'испанский'}, 
#               {'английский', 'французский'}, 
#               {'английский', 'немецкий'} ]

# for lang in languagies:
#    # print(lang)



# Словари (Dictionaries): Задачи для самостоятельной работы

# Задача 1: Подсчёт голосов

# Сценарий: Посчитать частоту появления каждого элемента в списке.
# •	На входе: Список строк. ['Маша', 'Петя', 'Вася', 'Маша', 'Петя', 'Маша']
# •	На выходе: Словарь {'элемент': частота}. {'Маша': 3, 'Петя': 2, 'Вася': 1}
# Подсказка: Ключевая логика — проверить, существует ли ключ в словаре, прежде чем пытаться увеличить его значение.

names = ['Маша', 'Петя', 'Вася', 'Маша', 'Петя', 'Маша', 'Николь']
dict_names = {name: names.count(name) for name in names}
# names.count()
print(dict_names)


# Задача 2: Бонусные баллы

# Сценарий: Обновить значения в словаре, если они удовлетворяют определённому условию.
# •	На входе: Словарь. grades = {'Иванов': 55, 'Петров': 72, 'Сидоров': 48}
# •	На выходе: Тот же словарь с измененными значениями. {'Иванов': 60, 'Петров': 72, 'Сидоров': 53}
# Подсказка: Для итерации с возможностью изменения словаря нужно правильно выбрать метод (.keys(), .values() или .items()).

grades = {'Иванов': 55, 'Петров': 72, 'Сидоров': 48}
# name_upd = ['Иванов', 'Сидоров']
# age = 5
# grades_upd = {grade + age if name in name_upd 
#               else grade for name, grade in grades.items()}
# print(grades_upd)

for name, grade in grades.items():
   if grade < 60:
      grades[name] = grade + 5

print(grades)


# Задача 3: Отбор дорогих товаров

# Сценарий: Создать новый словарь из пар ключ-значение исходного словаря, если значение удовлетворяет условию.
# •	На входе: Словарь. inventory = {'ручка': 20, 'книга': 800, 'рюкзак': 1500}
# •	На выходе: Новый, отфильтрованный словарь. {'книга': 800, 'рюкзак': 1500}
# Подсказка: Итерируйтесь по элементам исходного словаря и добавляйте подходящие пары в новый, заранее созданный пустой словарь.


inventory = {'ручка': 20, 'книга': 800, 'рюкзак': 1500}

inventory_new = {}

for item, price in inventory.items():
   if price > 500:
      inventory_new[item] = price

print(inventory_new)


# Задача 4: Инверсия словаря

# Сценарий: Преобразовать словарь {'ключ': 'значение'} в словарь {'значение': 'ключ'}. Гарантируется, что все значения в исходном словаре уникальны.
# •	На входе: Словарь. capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Италия': 'Рим'}
# •	На выходе: Инвертированный словарь. {'Москва': 'Россия', 'Париж': 'Франция', 'Рим': 'Италия'}
# Подсказка: Вам нужно будет пройти по парам «ключ-значение» исходного словаря и добавить их в новый, поменяв местами.


capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Италия': 'Рим'}

countries = {}

for country, capital in capitals.items():
   country_i = capital
   capital_i = country
   countries[country_i] = capital_i

print(countries)


# Задача 5: Доступ к вложенным данным

# Сценарий: У вас есть вложенный словарь и строка, представляющая "путь" к данным. Вам нужно написать код, который извлечёт значение по этому пути.
# •	На входе: Вложенный словарь и строка-путь. data = {'user': {'name': 'Alice', 'profile': {'theme': 'dark'}}}, path = 'user.profile.theme'
# •	На выходе: Значение, находящееся по этому пути. 'dark'
# Подсказка: Разбейте строку пути на части и используйте цикл, чтобы последовательно «погружаться» в словарь на каждом шаге.
